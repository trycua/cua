<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <script src="https://pfau-software.de/json-viewer/dist/iife/index.js"></script>
  <title>Trace Viewer - __PATH_NAME__</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; margin: 16px; color: #e5e7eb; background: #0e0e0c; }
    h1 { font-size: 18px; margin: 0 0 12px 0; color: #fff; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #49483e; vertical-align: top; padding: 8px; background: #272822; }
    th { background: #383830; }
    pre { white-space: pre-wrap; word-wrap: break-word; margin: 0; }
  </style>
  <style>
    .trace-img { cursor: zoom-in; position: relative; }
    .img-container { position: relative; display: inline-block; overflow: hidden; }
    .bbox-overlay { 
      position: absolute; 
      border: 2px solid rgba(255, 0, 0, 0.8); 
      background: rgba(255, 255, 0, 0.1); 
      pointer-events: none; 
      z-index: 10;
    }
    .bbox-label { 
      position: absolute; 
      background: rgba(255, 0, 0, 0.7); 
      color: white; 
      padding: 2px 4px; 
      font-size: 10px; 
      border-radius: 2px; 
      white-space: nowrap; 
      opacity: 0.1; 
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 11;
    }
    .bbox-label.pos-top { transform: translateY(0%); }
    .bbox-label.pos-right { transform: translateX(0%); }
    .bbox-label.pos-bottom { transform: translateY(0%); }
    .bbox-label.pos-left { transform: translateX(0%); }
    .bbox-overlay:hover + .bbox-label,
    .bbox-label:hover { opacity: 1; }
    
    /* Overlay styles for full-screen preview */
    #overlayImg { position: relative; }
    .overlay-container { position: relative; display: inline-block; }
    .overlay-bbox { 
      position: absolute; 
      border: 2px solid rgba(255, 0, 0, 0.9); 
      background: rgba(255, 255, 0, 0.15); 
      pointer-events: auto; 
      z-index: 1001;
      cursor: pointer;
    }
    .overlay-label { 
      position: absolute; 
      background: rgba(255, 0, 0, 0.8); 
      color: white; 
      padding: 4px 6px; 
      font-size: 12px; 
      border-radius: 3px; 
      white-space: nowrap; 
      opacity: 0.5; 
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 1002;
    }
    .overlay-label.pos-top { transform: translateY(0%); }
    .overlay-label.pos-right { transform: translateX(0%); }
    .overlay-label.pos-bottom { transform: translateY(0%); }
    .overlay-label.pos-left { transform: translateX(0%); }
    .overlay-bbox:hover + .overlay-label,
    .overlay-label:hover { opacity: 1; }
  </style>
</head>
<body>
  <h1>Trace Viewer - __PATH__</h1>
  <div style="margin-bottom: 16px;">
    <label style="display: flex; align-items: center; gap: 8px; color: #e5e7eb; cursor: pointer;">
      <input type="checkbox" id="overlaySnapshotCheckbox" checked style="cursor: pointer;">
      <span>overlay ARIA nodes in images</span>
    </label>
  </div>
  <div id="overlay" style="position:fixed; inset:0; background: rgba(0,0,0,0.75); display:none; align-items:center; justify-content:center; z-index: 1000;">
    <div id="overlayInner" style="display:flex; flex-direction:column; align-items:center; gap: 8px;">
      <div style="margin-bottom: 8px;">
        <label style="display: flex; align-items: center; gap: 8px; color: #e5e7eb; cursor: pointer;">
          <input type="checkbox" id="overlaySnapshotCheckboxFullscreen" checked style="cursor: pointer;">
          <span>overlay ARIA nodes in images</span>
        </label>
      </div>
      <div id="overlayImgContainer" class="overlay-container">
        <img id="overlayImg" src="" style="display:block; max-width:95vw; max-height:95vh; box-shadow: 0 10px 40px rgba(0,0,0,0.6); border: 1px solid #49483e;"/>
      </div>
      <div id="progressWrap" style="display:none; width:100%; margin:0; padding:0; background: transparent;">
        <div id="progressTrack" style="position:relative; height: 6px; background:#000; border: 1px solid #49483e;">
          <div id="progressBar" style="position:absolute; left:0; top:0; height: 100%; width: 0%; background: #2a2a2a;"></div>
          <div id="progressTicks" style="position:absolute; left:0; top:0; height:100%; width:100%; pointer-events:none;"></div>
        </div>
        <div id="progressLabel" style="display:grid; grid-template-columns: 1fr auto 1fr; gap: 8px; font-size: 12px; color: #cbd5e1; padding-top: 4px; margin:0; width:100%;">
          <span id="curTime" style="justify-self:start;">0:00</span>
          <span id="trajId" style="justify-self:center;">traj n/a</span>
          <span id="totalTime" style="justify-self:end;">0:00</span>
        </div>
      </div>
    </div>
  </div>
  <table>
    <thead>
      <tr>
        <th>features</th>
        <th>data_json</th>
        <th>images</th>
      </tr>
    </thead>
    <tbody>
      __ROWS__
    </tbody>
  </table>
  <script>
    (function() {
      const overlay = document.getElementById('overlay');
      const overlayImg = document.getElementById('overlayImg');
      const progressWrap = document.getElementById('progressWrap');
      let current = { row: -1, img: -1 };

      const ROW_META = __ROW_META__;
      const ROW_DATA_B64 = __ROW_DATA__;
      const ROW_DATA = JSON.parse(atob(ROW_DATA_B64));
      const bounds = new Map();

      // Collision detection for label positioning
      function checkCollision(rect1, rect2) {
        return !(rect1.right < rect2.left || 
                rect1.left > rect2.right || 
                rect1.bottom < rect2.top || 
                rect1.top > rect2.bottom);
      }

      function findBestLabelPosition(bboxRect, labelWidth, labelHeight, existingRects, scaleX, scaleY) {
        const positions = [
          { class: 'pos-top', x: bboxRect.x, y: bboxRect.y - labelHeight },
          { class: 'pos-bottom', x: bboxRect.x, y: bboxRect.y + bboxRect.height },
          { class: 'pos-right', x: bboxRect.x + bboxRect.width, y: bboxRect.y },
          { class: 'pos-left', x: bboxRect.x - labelWidth, y: bboxRect.y }
        ];

        for (const pos of positions) {
          const labelRect = {
            left: pos.x * scaleX,
            top: pos.y * scaleY,
            right: (pos.x + labelWidth) * scaleX,
            bottom: (pos.y + labelHeight) * scaleY
          };

          let hasCollision = false;
          for (const existingRect of existingRects) {
            if (checkCollision(labelRect, existingRect)) {
              hasCollision = true;
              break;
            }
          }

          if (!hasCollision) {
            return { position: pos, rect: labelRect };
          }
        }

        // If all positions collide, use top position as fallback
        const fallbackPos = positions[0];
        const fallbackRect = {
          left: fallbackPos.x * scaleX,
          top: fallbackPos.y * scaleY,
          right: (fallbackPos.x + labelWidth) * scaleX,
          bottom: (fallbackPos.y + labelHeight) * scaleY
        };
        return { position: fallbackPos, rect: fallbackRect };
      }

      // Parse HTML to extract bounding box data
      function parseBboxData(htmlString) {
        if (!htmlString) return [];
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlString, 'text/html');
        const elements = [];
        
        // Find all elements with data-bbox attributes
        const rootEl = doc.querySelector('html');
        const bboxElements = rootEl.querySelectorAll('[data-bbox-x][data-bbox-y][data-bbox-width][data-bbox-height]');
        
        bboxElements.forEach(el => {
          // Only include leaf elements (no child elements) that have aria-label
          const hasAriaLabel = el.hasAttribute('aria-label');
          const hasChildElements = el.children.length > 0;
          
          if (!hasAriaLabel || hasChildElements) {
            return; // Skip this element
          }
          
          const x = parseInt(el.getAttribute('data-bbox-x') || '0');
          const y = parseInt(el.getAttribute('data-bbox-y') || '0');
          const width = parseInt(el.getAttribute('data-bbox-width') || '0');
          const height = parseInt(el.getAttribute('data-bbox-height') || '0');
          
          // Get window screen offset
          let screenX = parseInt(rootEl.getAttribute('data-window-screen-x') || '0');
          let screenY = parseInt(rootEl.getAttribute('data-window-screen-y') || '0');

          // Create label from aria-label and element info
          let label = el.getAttribute('aria-label') || '';
          // label += ` (${el.tagName.toLowerCase()}`;
          // if (el.id) label += `#${el.id}`;
          // if (el.className) label += `.${el.className.split(' ')[0]}`;
          // label += ')';
          
          elements.push({
            x: x + screenX,
            y: y + screenY,
            width,
            height,
            label,
            element: el
          });
        });
        
        return elements;
      }

      // Create overlay elements for an image
      function createOverlays(imgElement, bboxData) {
        let container = imgElement.parentElement;
        if (!container || !container.classList.contains('img-container')) {
          // Wrap image in container if not already wrapped
          const wrapper = document.createElement('div');
          wrapper.className = 'img-container';
          imgElement.parentNode.insertBefore(wrapper, imgElement);
          wrapper.appendChild(imgElement);
          container = wrapper;
        }
        
        // Remove existing overlays
        container.querySelectorAll('.bbox-overlay, .bbox-label').forEach(el => el.remove());
        
        const checkbox = document.getElementById('overlaySnapshotCheckbox');
        if (!checkbox || !checkbox.checked) {
          return;
        }
        
        // Check if image has loaded and has dimensions
        if (!imgElement.naturalWidth || !imgElement.naturalHeight || !imgElement.clientWidth || !imgElement.clientHeight) {
          return;
        }
        
        // Calculate scale factors
        const scaleX = imgElement.clientWidth / imgElement.naturalWidth;
        const scaleY = imgElement.clientHeight / imgElement.naturalHeight;
        
        // Initialize existingRects with element bounding boxes to avoid placing labels on elements
        const existingRects = bboxData.map(bbox => ({
          left: bbox.x * scaleX + 4,
          top: bbox.y * scaleY + 4,
          right: (bbox.x + bbox.width) * scaleX - 4,
          bottom: (bbox.y + bbox.height) * scaleY - 4
        }));
        
        bboxData.forEach(bbox => {
          // Create overlay rectangle
          const overlay = document.createElement('div');
          overlay.className = 'bbox-overlay';
          overlay.style.left = (bbox.x * scaleX) + 'px';
          overlay.style.top = (bbox.y * scaleY) + 'px';
          overlay.style.width = (bbox.width * scaleX) + 'px';
          overlay.style.height = (bbox.height * scaleY) + 'px';
          
          // Create label with collision detection
          const label = document.createElement('div');
          label.className = 'bbox-label';
          label.textContent = bbox.label;
          
          // Estimate label dimensions (approximate)
          const labelWidth = bbox.label.length * 6 + 8; // rough estimate
          const labelHeight = 16;
          
          // Find best position for label
          const result = findBestLabelPosition(bbox, labelWidth, labelHeight, existingRects, scaleX, scaleY);
          
          label.style.left = (result.position.x * scaleX) + 'px';
          label.style.top = (result.position.y * scaleY) + 'px';
          label.classList.add(result.position.class);
          
          // Track this label's bounding box
          existingRects.push(result.rect);
          
          container.appendChild(overlay);
          container.appendChild(label);
        });
      }

      // Create overlays for full-screen preview
      function createFullScreenOverlays(imgElement, bboxData) {
        const container = document.getElementById('overlayImgContainer');
        
        // Remove existing overlays
        container.querySelectorAll('.overlay-bbox, .overlay-label').forEach(el => el.remove());
        
        const checkbox = document.getElementById('overlaySnapshotCheckboxFullscreen');
        if (!checkbox || !checkbox.checked) {
          return;
        }
        
        // Check if image has loaded and has dimensions
        if (!imgElement.naturalWidth || !imgElement.naturalHeight || !imgElement.clientWidth || !imgElement.clientHeight) {
          return;
        }
        
        // Calculate scale factors
        const scaleX = imgElement.clientWidth / imgElement.naturalWidth;
        const scaleY = imgElement.clientHeight / imgElement.naturalHeight;
        
        // Initialize existingRects with element bounding boxes to avoid placing labels on elements
        const existingRects = bboxData.map(bbox => ({
          left: bbox.x * scaleX + 4,
          top: bbox.y * scaleY + 4,
          right: (bbox.x + bbox.width) * scaleX - 4,
          bottom: (bbox.y + bbox.height) * scaleY - 4
        }));
        
        bboxData.forEach(bbox => {
          // Create overlay rectangle
          const overlay = document.createElement('div');
          overlay.className = 'overlay-bbox';
          overlay.style.left = (bbox.x * scaleX) + 'px';
          overlay.style.top = (bbox.y * scaleY) + 'px';
          overlay.style.width = (bbox.width * scaleX) + 'px';
          overlay.style.height = (bbox.height * scaleY) + 'px';
          
          // Create label with collision detection
          const label = document.createElement('div');
          label.className = 'overlay-label';
          label.textContent = bbox.label;
          
          // Estimate label dimensions (approximate, larger for full-screen)
          const labelWidth = bbox.label.length * 8 + 12; // rough estimate
          const labelHeight = 20;
          
          // Find best position for label
          const result = findBestLabelPosition(bbox, labelWidth, labelHeight, existingRects, scaleX, scaleY);
          
          label.style.left = (result.position.x * scaleX) + 'px';
          label.style.top = (result.position.y * scaleY) + 'px';
          label.classList.add(result.position.class);
          
          // Track this label's bounding box
          existingRects.push(result.rect);
          
          container.appendChild(overlay);
          container.appendChild(label);
        });
      }

      // Update overlays for all images
      function updateAllOverlays() {
        document.querySelectorAll('.trace-img').forEach(img => {
          const row = parseInt(img.getAttribute('data-row'));
          const rowData = ROW_DATA[row];
          
          if (rowData && rowData.snapshot && rowData.snapshot.windows) {
            const windows = rowData.snapshot.windows;
            let allBboxData = [];
            
            windows.forEach(window => {
              if (window.html) {
                const bboxData = parseBboxData(window.html);
                allBboxData = allBboxData.concat(bboxData);
              }
            });
            
            if (img.complete && img.naturalWidth > 0) {
              createOverlays(img, allBboxData);
            } else {
              img.onload = () => createOverlays(img, allBboxData);
            }
          }
        });
      }
      function toTime(v) {
        if (v == null) return NaN; if (typeof v === 'number') return v; const t = Date.parse(v); return isNaN(t) ? NaN : t;
      }
      function fmtMMSS(ms) {
        if (!isFinite(ms) || ms < 0) ms = 0; const sec = Math.floor(ms / 1000); const m = Math.floor(sec / 60); const s = sec % 60; return m + ':' + String(s).padStart(2, '0');
      }
      for (let i = 0; i < ROW_META.length; i++) {
        const m = ROW_META[i] || {}; const tid = m.trajectory_id ?? 'default'; const t = toTime(m.timestamp);
        if (isNaN(t)) continue; const cur = bounds.get(tid) || { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
        if (t < cur.min) cur.min = t; if (t > cur.max) cur.max = t; bounds.set(tid, cur);
      }

      function updateProgress(rowIdx) {
        if (rowIdx < 0 || rowIdx >= ROW_META.length) return;
        const m = ROW_META[rowIdx] || {}; const tid = m.trajectory_id ?? 'default'; const t = toTime(m.timestamp); const b = bounds.get(tid);
        const bar = document.getElementById('progressBar'); const curEl = document.getElementById('curTime'); const idEl = document.getElementById('trajId'); const totalEl = document.getElementById('totalTime'); const ticksEl = document.getElementById('progressTicks');
        if (!b || isNaN(t) || !(typeof b.min === 'number') || !(typeof b.max === 'number') || b.min === Infinity || b.max === -Infinity || b.max <= b.min) {
          bar.style.width = '0%'; curEl.textContent = '0:00'; idEl.textContent = 'traj ' + tid; totalEl.textContent = '0:00'; if (ticksEl) ticksEl.innerHTML = ''; return;
        }
        const total = Math.max(0, b.max - b.min); const elapsed = Math.max(0, t - b.min); const ratio = total > 0 ? Math.max(0, Math.min(1, elapsed / total)) : 0;
        bar.style.width = (ratio * 100).toFixed(1) + '%'; curEl.textContent = fmtMMSS(elapsed); idEl.textContent = 'traj ' + tid; totalEl.textContent = fmtMMSS(total);
        const w = overlayImg.clientWidth; if (w && w > 0) { progressWrap.style.width = w + 'px'; }
        const ticksEl2 = document.getElementById('progressTicks'); if (ticksEl2) {
          const frag = document.createDocumentFragment(); ticksEl2.innerHTML = '';
          for (let i = 0; i < ROW_META.length; i++) { const rm = ROW_META[i] || {}; if ((rm.trajectory_id ?? 'default') !== tid) continue; const ti = toTime(rm.timestamp); if (isNaN(ti)) continue; const ri = total > 0 ? Math.max(0, Math.min(1, (ti - b.min) / total)) : 0; const tick = document.createElement('div'); tick.style.position = 'absolute'; tick.style.left = (ri * 100) + '%'; tick.style.top = '0'; tick.style.bottom = '0'; const isCurrent = (i === rowIdx); tick.style.width = isCurrent ? '3px' : '1px'; tick.style.background = isCurrent ? '#ffffff' : '#cbd5e1'; tick.style.opacity = isCurrent ? '1' : '0.6'; frag.appendChild(tick); }
          ticksEl2.appendChild(frag);
        }
      }

      function getRowEl(row) { const rowEls = Array.from(document.querySelectorAll('tbody tr')); return rowEls[row] || null; }
      function scrollToRow(row) { const el = getRowEl(row); if (!el) return; try { el.scrollIntoView({ block: 'center' }); } catch (e) { const top = el.getBoundingClientRect().top + window.scrollY - (window.innerHeight / 2); window.scrollTo(0, Math.max(0, top)); } }
      function showOverlay(row, img) { 
        const sel = 'img.trace-img[data-row="' + row + '"][data-img="' + img + '"]'; 
        const el = document.querySelector(sel); 
        if (!el) return; 
        
        current.row = row; 
        current.img = img; 
        overlayImg.src = el.src; 
        overlay.style.display = 'flex'; 
        progressWrap.style.display = 'block'; 
        scrollToRow(row); 
        updateProgress(row); 
        
        // Create overlays for full-screen preview
        const rowData = ROW_DATA[row];
        if (rowData && rowData.snapshot && rowData.snapshot.windows) {
          const windows = rowData.snapshot.windows;
          let allBboxData = [];
          
          windows.forEach(window => {
            if (window.html) {
              const bboxData = parseBboxData(window.html);
              allBboxData = allBboxData.concat(bboxData);
            }
          });
          
          if (overlayImg.complete && overlayImg.naturalWidth > 0) {
            createFullScreenOverlays(overlayImg, allBboxData);
          } else {
            overlayImg.onload = () => createFullScreenOverlays(overlayImg, allBboxData);
          }
        }
      }
      function hideOverlay() { 
        overlay.style.display = 'none'; 
        progressWrap.style.display = 'none'; 
        current.row = -1; 
        current.img = -1; 
        
        // Clean up full-screen overlays
        const container = document.getElementById('overlayImgContainer');
        container.querySelectorAll('.overlay-bbox, .overlay-label').forEach(el => el.remove());
      }
      window.addEventListener('resize', () => { 
        if (overlay.style.display === 'flex' && progressWrap.style.display === 'block') { 
          const w = overlayImg.clientWidth; 
          if (w && w > 0) progressWrap.style.width = w + 'px'; 
          
          // Update full-screen overlays on resize
          if (current.row >= 0) {
            const rowData = ROW_DATA[current.row];
            if (rowData && rowData.snapshot && rowData.snapshot.windows) {
              const windows = rowData.snapshot.windows;
              let allBboxData = [];
              
              windows.forEach(window => {
                if (window.html) {
                  const bboxData = parseBboxData(window.html);
                  allBboxData = allBboxData.concat(bboxData);
                }
              });
              
              setTimeout(() => createFullScreenOverlays(overlayImg, allBboxData), 100);
            }
          }
        } 
      });
      function maxImgIndex(row) { const sel = 'img.trace-img[data-row="' + row + '"]'; const imgs = document.querySelectorAll(sel); return imgs.length - 1; }
      function navigate(dxRow, dxImg) {
        if (current.row === -1) return; let newRow = current.row + dxRow; const rowEls = Array.from(document.querySelectorAll('tbody tr'));
        const clampRow = (r) => { if (r < 0) return 0; if (r >= rowEls.length) return rowEls.length - 1; return r; }; newRow = clampRow(newRow);
        let newImg = current.img + dxImg; const maxIdx = maxImgIndex(newRow); if (maxIdx < 0) return; if (newImg < 0) newImg = 0; if (newImg > maxIdx) newImg = maxIdx; scrollToRow(newRow); showOverlay(newRow, newImg); updateProgress(newRow);
      }
      // Event listeners
      document.addEventListener('click', (e) => { const t = e.target; if (t && t.classList && t.classList.contains('trace-img')) { const row = parseInt(t.getAttribute('data-row')); const img = parseInt(t.getAttribute('data-img')); showOverlay(row, img); } else if (t && (t.id === 'overlay')) { hideOverlay(); } });
      window.addEventListener('keydown', (e) => { if (overlay.style.display !== 'flex') return; switch (e.key) { case 'Escape': hideOverlay(); break; case 'ArrowLeft': e.preventDefault(); navigate(0, -1); break; case 'ArrowRight': e.preventDefault(); navigate(0, +1); break; case 'ArrowUp': e.preventDefault(); navigate(-1, 0); break; case 'ArrowDown': e.preventDefault(); navigate(+1, 0); break; } });
      
      // Checkbox event listeners
      document.getElementById('overlaySnapshotCheckbox').addEventListener('change', updateAllOverlays);
      
      // Sync checkboxes and handle fullscreen checkbox changes
      document.getElementById('overlaySnapshotCheckbox').addEventListener('change', function() {
        document.getElementById('overlaySnapshotCheckboxFullscreen').checked = this.checked;
      });
      
      document.getElementById('overlaySnapshotCheckboxFullscreen').addEventListener('change', function() {
        document.getElementById('overlaySnapshotCheckbox').checked = this.checked;
        updateAllOverlays();
        
        // Update fullscreen overlays if currently in fullscreen mode
        if (current.row >= 0) {
          const rowData = ROW_DATA[current.row];
          if (rowData && rowData.snapshot && rowData.snapshot.windows) {
            const windows = rowData.snapshot.windows;
            let allBboxData = [];
            
            windows.forEach(window => {
              if (window.html) {
                const bboxData = parseBboxData(window.html);
                allBboxData = allBboxData.concat(bboxData);
              }
            });
            
            const overlayImg = document.getElementById('overlayImg');
            if (overlayImg.complete && overlayImg.naturalWidth > 0) {
              createFullScreenOverlays(overlayImg, allBboxData);
            }
          }
        }
      });
      
      // Initialize overlays when page loads
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(updateAllOverlays, 100); // Small delay to ensure images are loaded
      });
      
      // Update overlays when window resizes
      window.addEventListener('resize', () => {
        setTimeout(updateAllOverlays, 100);
      });
    })();
  </script>
</body>
</html>
