"""{{agent_name}} - Custom agent implementation."""

from pathlib import Path
from typing import TYPE_CHECKING

from cua_bench.agents import BaseAgent, AgentResult, FailureMode

if TYPE_CHECKING:
    from cua_bench.sessions import DesktopSession


class {{class_name}}(BaseAgent):
    """Custom agent implementation.

    This agent template provides a starting point for building your own
    computer-use agent. Implement the perform_task method to define
    how your agent interacts with the desktop environment.
    """

    def __init__(self, **kwargs):
        """Initialize the agent.

        Args:
            **kwargs: Configuration options including:
                - model: Model identifier (default: "gpt-4o")
                - max_steps: Maximum steps per task (default: 50)
        """
        super().__init__(**kwargs)
        self.model = kwargs.get("model", "gpt-4o")
        self.max_steps = kwargs.get("max_steps", 50)

    @staticmethod
    def name() -> str:
        """Return the agent name."""
        return "{{agent_name}}"

    async def perform_task(
        self,
        task_description: str,
        session: "DesktopSession",
        logging_dir: Path | None = None,
    ) -> AgentResult:
        """Execute the task.

        This method is called to perform a single task. The agent should:
        1. Take screenshots to observe the current state
        2. Decide on actions based on the task description
        3. Execute actions using the session
        4. Repeat until the task is complete or max_steps is reached

        Args:
            task_description: What the agent should accomplish
            session: Desktop session for computer control
            logging_dir: Optional directory for saving logs/screenshots

        Returns:
            AgentResult with token counts and failure mode
        """
        total_input_tokens = 0
        total_output_tokens = 0

        for step in range(self.max_steps):
            # 1. Take a screenshot to observe current state
            screenshot = await session.screenshot()

            # 2. Call your model to decide the next action
            # Example (implement your own logic):
            # response = await self.call_model(
            #     screenshot=screenshot,
            #     task=task_description,
            #     history=action_history,
            # )
            # action = response.action
            # total_input_tokens += response.input_tokens
            # total_output_tokens += response.output_tokens

            # 3. Execute the action
            # Example actions:
            # await session.click(x=100, y=200)
            # await session.type("Hello world")
            # await session.key("Enter")
            # await session.scroll(x=100, y=200, direction="down")

            # 4. Check if the task is complete
            # if response.is_done:
            #     break

            # TODO: Implement your agent logic here
            # For now, just break to avoid infinite loop
            break

        return AgentResult(
            total_input_tokens=total_input_tokens,
            total_output_tokens=total_output_tokens,
            failure_mode=FailureMode.NONE,
        )

    # Optional: Add helper methods for your agent
    # async def call_model(self, screenshot, task, history):
    #     """Call your LLM to get the next action."""
    #     pass
